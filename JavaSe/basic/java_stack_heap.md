#### Java中的栈内存和堆空间

> [Stack Memory and Heap Space in Java](https://www.baeldung.com/java-stack-heap)

#### 1.简介

为了以最佳方式运行应用程序，JVM将内存划分为栈和堆内存。**每当我们声明新的变量和对象，调用新方法，声明一个字符串或者类似这样的操作时，JVM就会从栈内存或者堆空间中为这些操作指定内存**。

在这篇文章中，我们将会讨论这些内存模型。我们将列出它们之间的一些关键区别，它们如何存储在RAM中，它们提供的特性以及在哪使用它们。

#### 2. Java中的栈内存

**在Java中的栈内存被用于静态内存分配和线程的执行**。它包含特定于方法的基本值，以及对该方法中引用的对堆中对象的引用。

访问这个内存是基于后进先出（LIFO）规则。无论何时调用新方法，都会在栈顶部创建一个新块，它包含特定于方法的值，如基本变量和对象的引用。

当方法执行完成时，对应的栈帧被刷新，流程返回到调用方法，并且空间空间可用于下一个方法。

##### 2.1 栈内存的主要特点

除了我们目前为止讨论的，以下是堆栈内存的一些其他特性：

+ 它随着新方法的调用和返回而增长和缩小。
+ 栈中的变量只在创建它们的方法运行时存在
+ 当方法完成执行时，它自动分配和释放
+ 如果此内存已满，Java抛出java.lang.StackOverFlowError
+ 与堆内存相比，对该内存的访问速度更快
+ 这个内存是线程安全的，因为每个线程都在自己的栈中运行

#### 3 Java中的堆空间

**Java中的堆空间用于在运行时为Java对象和JRE类分配动态内存**。新对象总是在堆空间中创建，对该对象的引用存储在栈内存中。

这些对象具有全局访问权，可以从应用程序中的任何位置访问。

这个内存模型进一步细分为更小部分，称为代，它们是：

1. **年轻代** —— 这是分配和老化所有新对象的地方。当被填满时会发生较小的垃圾回收。

2. **老年代** —— 这是存储长期存活对象的地方。当对象存储在年轻代时，设置对象年龄的阀值，当达到该阀值时，对象奖移动到老年代。

3. **永久代** —— 它由运行时类和应用程序方法的JVM元数据组成。

它们的不同之处也在这篇文章中也有讨论—— [JVM,JRE和JDK之间的差异](https://www.baeldung.com/jvm-vs-jre-vs-jdk)。

我们总是可以根据需要来操作堆内存的大小。有关更多信息，请访问这篇链接的[Baeldung的文章](https://www.baeldung.com/jvm-parameters)。

##### 3.1 Java堆内存的主要特点

除来目前为止我们讨论的，以下也是关于堆空间的其他一些特点：

+ 它是通过复杂的内存管理技术访问的，这些技术包括年轻代，老年代和永久代。
+ 如果堆空间满了，Java就会抛出`java.lang.OutOfMemoryError`
+ 





