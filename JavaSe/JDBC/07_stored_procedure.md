### JDBC调用存储过程

通过`JDBC`我们也能调用数据库中的存储过程，`CallableStatement`对象为所有的`BMS`提供了一种以标准形式调用已储存过程的方法。

#### 无参无返回值存储过程调用

首先创建一个存储过程，创建脚本如下：

```sql
DROP PROCEDURE IF EXISTS test1;
create PROCEDURE `test1`()
BEGIN
	insert into db_user(user_name,`password`,email,birthday) values('abc','abc123','abc@163.com','1998-10-11');
	commit;
END
```

是一个非常简单的存储过程，只需要在`db_user`表中新增一条数据即可，下面我们来使用`JDBC`来执行存储过程

```java
    /**
     * 无参无返回值
     */
    @Test
    public void test1(){
        Connection connection = null;
        CallableStatement statement = null;

        try {
            connection = SelfDbUtils.getInstance().getConnection();

            String sql = "{call test1()}";

            statement = connection.prepareCall(sql);
            statement.executeUpdate();
        } catch (SQLException e) {
            throw new DaoException("存储过程出错",e);
        } finally {
            SelfDbUtils.getInstance().close(connection,statement,null);
        }
    }
```

执行完毕之后会在数据库中查看新增了一条记录；

#### 有参无返回值存储过程调用

修改存储过程，将存储过程变为如下

```sql
DROP PROCEDURE IF EXISTS test2;
create PROCEDURE `test2`(in _userName varchar(225),in _password varchar(225),in _email varchar(225),in _birthday DATE )
BEGIN
	insert into db_user(user_name,`password`,email,birthday) values(_userName, _password, _email, _birthday);
	commit;
END

```

可以看到在该存储过程中新增加了几个入参，这样我们可以通过使用`Callablestatement`所提供的`set`方法对其进行赋值，代码演示如下

```java
    /**
     * 有参无返回值
     */
    @Test
    public void test2(){
        Connection connection = null;
        CallableStatement statement = null;

        try {
            connection = SelfDbUtils.getInstance().getConnection();

            String sql = "{call test2(?,?,?,?)}";

            statement = connection.prepareCall(sql);
            statement.setString(1,"qaz");
            statement.setString(2,"qazxsw");
            statement.setString(3,"qaz@163.com");
            statement.setDate(4, new Date(new SimpleDateFormat("yyyy-MM-dd").parse("1998-10-11").getTime()));
            statement.executeUpdate();
        } catch (Exception e) {
            throw new DaoException("存储过程出错",e);
        } finally {
            SelfDbUtils.getInstance().close(connection,statement,null);
        }
    }
```

执行之后，我们的数据库中又增加了一条记录

#### 有参有返回值存储过程调用

再次修改存储过程，让其支持值返回

```sql
DROP PROCEDURE IF EXISTS test3;
create PROCEDURE `test3`(in _userName varchar(225), in _password varchar(225), in _email varchar(225), in _birthday DATE, out _result INTEGER )
BEGIN
	insert into db_user(user_name,`password`,email,birthday) values(_userName, _password, _email, _birthday);
	commit;
	select count(1) from db_user into _result;
END
```

编写测试代码，在需要将值返回时，需要对其进行注册，代码演示如下

```java
    /**
     * 有参有返回值
     */
    @Test
    public void test3(){
        Connection connection = null;
        CallableStatement statement = null;

        try {
            connection = SelfDbUtils.getInstance().getConnection();

            String sql = "{call test3(?,?,?,?,?)}";

            statement = connection.prepareCall(sql);
            statement.setString(1,"qaz");
            statement.setString(2,"qazxsw");
            statement.setString(3,"qaz@163.com");
            statement.setDate(4, new Date(new SimpleDateFormat("yyyy-MM-dd").parse("1998-10-11").getTime()));
            statement.registerOutParameter(5, Types.INTEGER);
            statement.executeUpdate();

            int count = statement.getInt(5);
            System.out.println(count);
        } catch (Exception e) {
            throw new DaoException("存储过程出错",e);
        } finally {
            SelfDbUtils.getInstance().close(connection,statement,null);
        }
    }
```

至此，关于存储过程的调用已经OK了，接口也比较简单，熟悉`Statement`或者`PreparedStatement`熟悉起来就非常简单，复杂的地方就是存储过程的编写。

#### JDBC其他API

假设，我们的表中有一个自动生成的主键，我们插入了一条数据，但是此时还想要将该主键的数值获取出来，这个时候怎么做呢？在查询一次么？不用了， JDBC API 已经提供了这样的方法可以方便我们的使用，查看`Connection`的重载方法

```java
PreparedStatement prepareStatement(String sql,
                                 int autoGeneratedKeys)
                                   throws SQLException

Parameters:
sql - an SQL statement that may contain one or more '?' IN parameter placeholders
autoGeneratedKeys - a flag indicating whether auto-generated keys should be returned; one of Statement.RETURN_GENERATED_KEYS or Statement.NO_GENERATED_KEYS
Returns:
a new PreparedStatement object, containing the pre-compiled SQL statement, that will have the capability of returning auto-generated keys
```

代码演示如下

```java
    /**
     * 获取插入的主键
     */
    @Test
    public void test4(){
        Connection connection = null;
        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            connection = SelfDbUtils.getInstance().getConnection();
            String sql = "insert into db_user(user_name,`password`,email,birthday) values(?, ?, ?, ?);";
            statement = connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
            statement.setString(1,"jkl");
            statement.setString(2,"jkl123");
            statement.setString(3,"jkl@163.com");
            statement.setDate(4, new Date(new SimpleDateFormat("yyyy-MM-dd").parse("1998-10-11").getTime()));
            statement.executeUpdate();

            resultSet = statement.getGeneratedKeys();
            while (resultSet.next()){
                System.out.println(resultSet.getInt(1));
            }
        } catch (Exception e) {
            throw new DaoException("新增出错",e);
        } finally {
            SelfDbUtils.getInstance().close(connection,statement,resultSet);
        }
    }
```

