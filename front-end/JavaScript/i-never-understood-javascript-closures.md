### [译]我从未理解过的JavaScript闭包

> [i-never-understood-javascript-closures](https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8)

​        正如标题所述，JavaScript闭包对我来说一直是一个迷，我看了许多文章，在我工作中我也使用过闭包，有时候我甚至使用了闭包而没意识到我正在使用闭包。

​        最近我去参加一个演讲，有人用一种让我感兴趣的方式来解释它。我也准备在这篇文章中通过这种方式来解释闭包。让我向[CodeSmith](https://www.codesmith.io/)的优秀成员以及他们的*JavaScript The Hard Parts*系列表示敬意。

#### 在我们开始之前

在理解闭包之前我们需要理解一些重要的概念，其中之一就是**执行上下文**。这篇文章[What is the Execution Context & Stack in JavaScript?](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/#first-article)对执行上下文有一个很好的说明，引用这篇文章的内容：

>代码在JavaScript中执行时，执行它的环境是非常重要的，并被评估为以下几项之一：
>
>**全局代码** —— 第一次执行代码时的默认环境
>
>**函数代码** —— 每当执行流程进入到函数体时
>
>(...)
>
>(…)，让我们把`执行上下文`视为正在评估当前代码的环境/作用域

就是说，当我们启动程序时，我们从全局执行上下文开始。一些变量在全局执行上下文中声明。我们将这些变量称为全局变量。当程序调用函数时，会发生什么？几个步骤：

1. JavaScript创建一个新的执行上下文，一个局部执行上下文
2. 这个局部执行上下文将有一组自己的变量，这些变量将是局部执行上下文的本地变量
3. 这个新的执行上下文将会抛出到**执行堆栈**中。将执行堆栈视为一种机制，可以跟踪程序执行的位置。

函数什么时候结束？当它碰到一个`return`语句或者是碰到一个结束括号`}`。当函数结束时，会执行以下步骤：

1. 局部执行上下文从执行堆栈中弹出
2. 函数将返回值发送给调用上下文。调用上下文就是调用这个函数的执行上下文，它可能时全局上下文或者是另一个局部执行上下文。它取决于调用执行上下文处理这个返回值所处的位置。这个返回值可以是一个对象、一个数组、一个函数、一个布尔值，甚至是任何东西。如果这个函数没有`return`语句，将会返回`undefined`。
3. 这个局部执行上下文将会被销毁，这很重要。销毁，所有在局部执行上下文中声明的变量将会被擦除。它们将不在存在。这也是为什么它们被称为局部变量的原因。

#### 一个非常基本的例子

在我们学习闭包之前，让我们来看看下面这段代码。这似乎非常简单，阅读这篇文章的任何人都可能知道它如何执行的。

```javascript
1: let a = 3
2: function addTwo(x) {
3:   let ret = x + 2
4:   return ret
5: }
6: let b = addTwo(a)
7: console.log(b)
```

为了理解JavaScript引擎真正的工作原理，让我们详细分析一下。

1. 在第一行在全局上下文中声明了一个变量`a`，并将数字`3`分配给了它。

2. 接下来它变得棘手了。第二行到第五行是真的在一起的。这里发生了什么？我们在全局上下文中声明了一个变量`addTwo`。我们分配给它什么呢？一个函数定义。两个括号`{}`之间的任何内容都分配给变量`addTwo`。该函数内的代码并未被获取，未被执行，只是存入到一个变量中供我们将来使用。

3. 现在让我们看看第六行，它看起来很简单，但这里需要解开很多细节。首先我们在全局上下文中声明了一个变量，并将其标记为`b`，声明变量后，它的值为`undefined`。

4. 接下来，还是在第六行，我们看见了一个赋值操作符，我们准备为变量`b`分配一个新的值，接下来我们看到一个被调用的函数，当你看到一个变量后面跟着圆括号`(...)`，那就是一个函数被调用的信号。快进，每个函数都会返回一些东西（也许是一个值，一个对象或者`undefined`）。无论这个函数返回什么都会分配给变量`b`。

5. 但是首先我们需要调用标记为`addTwo`的函数。JavaScript会在全局上下文的内存中查找一个叫做`addTwo`的变量。噢，它找到了一个，它是定义在步骤二（或者说第二到五行）。并且看到变量`addTwo`包含一个函数定义。请注意，变量`a`是作为一个参数传递给函数。JavaScript在全局上下文的内存中查找一个叫`a`的变量，找到它了，发现它的值是`3`并且将数字`3`作为一个参数传递给函数。准备执行该函数。

6. 现在这个执行上下文将会被切换。一个新的局部执行上下文将会被创建，让我们将它命名为`addTwo的执行上下文`。这个执行上下文将会被推送到调用堆栈中，我们在局部上下文中做的第一件事是什么呢？

7. 你可能会想说：“在局部上下文中声明一个新的变量`ret`。这并不是答案。正确的答案是，我们首先需要查看函数的参数，在局部上下文中声明一个新的变量`x`。并且在之前我们将值`3`作为参数传递过来了，将数字`3`分配给变量`x`。

8. 下一步是：在局部上下文中声明一个新的变量`ret`。它的值将会被设置为`undefined`（就像步骤三一样）

9. 还是在第三行，一个加法需要被执行，首先我们需要变量`x`的值，JavaScript将会查找一个叫做`x`的变量。它首先会在局部上下文中查找这个变量，它找到了一个，这个值是`3`。第二个操作数是数字`2`。这个加法的结果（`5`）将会被分配给变量`ret`。

10. 第四行，我们将变量`ret`的内容返回。在局部上下文中再次查找，`ret`的值为`5`。这个函数返回数字`5`，函数结束。

11. 第四到第五行。函数结束。这个局部执行上下文将会被销毁，变量`ret`和`x`将会被擦除。它们将不在存在。这个上下文将会从执行堆栈中压出，并且将返回值返回给调用上下文。在当前情况下，调用上下文就是全局上下文，因为函数`addTwo`是在全局上下文中被调用的。

12. 现在我们来看看我们在第四步中停下来的地方。这个返回值（`数字5`）将会分配给变量`b`。我们仍然在小程序的第六行。

13. 我不再细讲了，但是在第七行，这个变量`b`的内容将会在控制台打印出来。在我们的例子中就是数字`5`。

对于一个非常简单的程序来说，这是一个非常冗长的解释。我们甚至还没涉及到闭包。我保证会到达那里，但是我们还得再绕一两次。

#### 词法作用域

我们需要了解词法作用域的某些方面。看一下下面的例子。

```javascript
1: let val1 = 2
2: function multiplyThis(n) {
3:   let ret = n * val1
4:   return ret
5: }
6: let multiplied = multiplyThis(6)
7: console.log('example of scope:', multiplied)
```

这里的想法是，我们在全局上下文中有一些变量，在局部上下文中也有一些变量。JavaScript的一个复杂之处在于它如何查找这些变量。如果它在局部上下文中未找到该变量，它将会去调用上下文中查找，如果在它的调用上下文中还是未找到该变量。反复地，直到它在全局上下文中查找该变量（如果它没有找到该变量，该变量的值就是`undefined`）。按照上面的例子，它将会证明这个说法。如果你知道作用域的工作原理，你可以跳过这节内容。

1. 在全局上下文中声明一个变量`val1`并且将数字`2`分配给它。
2. 第二到五行，声明一个新的变量`multiplyThis`并且给它分配一个函数定义。
3. 第六行在全局上下文中声明一个新的变量`mutiplied`。
4. 在全局上下文的内存中取出变量`multiplyThis`的值并将其作为函数执行。将数字`6`作为参数传递给它。
5. 一个新的函数调用 = 一个新的执行上下文。创建一个新的局部上下文。
6. 在局部上下文中，声明一个变量`n`并分配给它一个数字`6`。
7. 第三行，在局部上下文中，声明一个变量`ret`。
8. 第三行（再次），用两个操作数执行乘法操作；变量`n`和`val1`的内容，在局部上下文中查找到了变量`n`。我们在步骤6中声明了它。它的内容是数字`6`。在局部上下文中查找变量`val1`，局部执行上下文中并没有找到标记为`val1`的变量。我们来检查调用上下文。这个调用上下文就是全局上下文。让我们在全局上下文中查找变量`val1`，噢，是的，它就在那里，它在步骤1中定义的，它的值是数字`2`。
9. 第三行（再次），用两个操作数做乘法操作并将结果分配给变量`ret`。6 * 2 = 12。现在变量`ret`的值是`12`。
10. 返回变量`ret`。这个局部上下文被销毁，伴随着它的局部变量`ret`和`n`。变量`val1`并不会被销毁，因为它是全局上下文的一部分。
11. 回到第六行，在这个调用上下文中，数字`12`将会分配给变量`multiplied`。
12. 最后在第七行，我们在控制台打印变量`multiplied`。

所以在这个例子中，我们需要记住函数可以访问在其调用上下文中定义的变量。这种现象的正式名称是词法作用域。

#### 一个返回函数的函数

在第一个例子中函数`addTwo`返回的是一个数字。从之前的内容我们记得函数能够返回任何东西。让我们看一个返回函数的函数，因为这对理解闭包很重要。以下是我们要分析的例子。

```JavaScript
 1: let val = 7
 2: function createAdder() {
 3:   function addNumbers(a, b) {
 4:     let ret = a + b
 5:     return ret
 6:   }
 7:   return addNumbers
 8: }
 9: let adder = createAdder()
10: let sum = adder(val, 8)
11: console.log('example of function returning a function: ', sum)
```

让我们回到逐步分解。

1. 第一行，我们在全局上下文中声明了一个变量`val`并将数字`7`分配给这个变量。

2. 第二到八行，我们在全局上下文中声明了一个变量`createAdder`并将一个函数定义分配给了它。第三到七行描述了函数定义。像之前一样，在这个点，我们并没有跳进这个函数。我们只是将函数定义存储到该变量（`createAdder`）中。

3. 第九行，我们在全局上下文中声明了一个名为`adder`的新的变量。暂时将`undefined`分配给变量`adder`。

4. 还是在第九行，我们看见圆括号`()`；我们需要执行或者调用一个函数。我们在全局上下文的内存中查询一个名为`createAdder`的变量。它是在步骤二中创建的。好的，让我们调用它。

5. 调用函数。现在我们在第二行。一个新的局部执行上下文将会被创建。我们可以在这个新的执行上下文中创建局部变量。引擎将新的执行上下文添加到调用堆栈中。让我们直接进入它的函数体内。

6. 还是在3-6行。我们有一个新的函数声明。我们在局部执行上下文中创建了一个变量`addNumbers`。这很重要。变量`addNumbers`仅在局部执行上下文中存在。我们将函数定义存储在名为`addNumbers`的局部变量中。

7. 现在我们在第七行。我们将变量`addNumbers`的内容返回。引擎将会查找名为`addNumbers`的变量并找到它。它是一个函数定义。很好，一个函数可以返回任何东西，包括函数定义。所以我们将`addNumbers`的函数定义返回。在第四和第五行的大括号之间的任何内容构成了函数定义。我们也会将局部执行上下文从调用堆栈中移除。

8. 在`return`之后。这个局部执行上下文将会被销毁，变量`addNumbers`不再存在。函数定义仍然存在，它通过函数返回并分配给变量`adder`。这是我们在步骤3中创建的变量。

9. 现在我们在第十行，在全局执行上下文中声明了一个新的变量`sum`。暂时将`undefined`分配给它。

10. 接下来我们需要执行一个函数，哪一个函数？在名为`adder`变量中定义的函数。我们在全局执行上下文中查找它，我们确实找到了它。这是一个带两个参数的函数。

11. 让我们检索两个参数，这样我们就可以调用函数并传递正确的参数。第一个参数是我们在步骤一中定义的变量`val`，它代表数字`7`。第二个参数是数字`8`。

12. 现在我们开始执行这个函数。函数定义的概述在第三到五行。一个新的局部执行上下文将会被创建。在本地上下文中，创建两个新的变量`a`和`b`：它们分别被赋值为`7`和`8`，因为那些是我们在上一步中传递给函数的参数。

13. 第四行，声明一个新的名为`ret`的变量，它在这个局部执行上下文中声明的。

14. 第四行，执行加法操作，其中我们将变量`a`的内容和变量`b`的内容相加。将加法的结果（`15`）分配给变量`ret`。

15. 将变量`ret`从函数中返回。这个局部执行上下文将会被销毁，将其从执行堆栈中移除，变量`a`，`b`和`ret`将不在存在。

16. 将返回值赋值给我们在步骤九中定义的变量`sum`。

17. 将变量`sum`的值在控制台中打印输出。


正如所料，控制台打印输出`15`。我们确实经历了很多困难。我想在这里说明几点。首先，函数的定义可以存储在变量中，函数定义在程序调用它之前都是不可见的，第二，每次调用函数时，（临时）创建一个局部执行上下文。当函数执行完时这个执行上下文就会消失。函数在遇到`return`语句或者结束括号`}`时完成。

#### 最后，闭包

来看看下面的代码，并试着弄清楚会发生什么。

```javascript
 1: function createCounter() {
 2:   let counter = 0
 3:   const myFunction = function() {
 4:     counter = counter + 1
 5:     return counter
 6:   }
 7:   return myFunction
 8: }
 9: const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log('example increment', c1, c2, c3)
```

既然我们从前面两个例子得到了窍门，让我们压缩执行过程，正如我们所期望的那样。

1. 第一到八行，在全局执行上下文中创建一个新的变量`createCounter`，并分配给它一个函数定义。
2. 第九行，在全局执行上下文中声明了一个名为`increment`的新变量。
3. 还是在第九行，我们需要调用函数`createCounter`，并且将函数返回值分配给变量`increment`。
4. 第一到八行，调用函数。创建一个新的局部执行上下文。
5. 第二行，在局部执行上下文中声明了一个名为`counter`的新变量，并将数字`0`分配给`counter`。
6. 第三到六行，声明一个新的名为`myFunction`的变量。这个变量声明在局部执行上下文中。这个变量的内容是另一个函数定义。如第四和第五行所定义的。
7. 第七行，将变量`myfunction`的内容作为返回值。删除局部执行上下文。`myFunction`和`counter`将不再存在。控制器将返回到当前调用的上下文。
8. 第九行，在当前调用上下文中，实际就是全局执行上下文。函数`createCounter`的返回值将分配给变量`increment`。变量`increment`现在包含一个函数定义，由变量`createCounter`返回的函数定义。它不再标记为`myFunction`，但是它是相同的函数定义。在全局上下文中，它被标记为`increment`。
9. 第十行，声明一个新的变量（`c1`）。
10. 第十行（再次），查找变量`increment`，发现它是一个函数，调用它。它包含从前面返回的函数定义，如第四到第五行所定义的。
11. 创建一个新的执行上下文。没有参数。开始执行这个函数。
12. 第四行，`counter = counter + 1`。在局部执行上下文中查找变量`counter`。我们刚刚只是创建了上下文，并没有声明任何局部变量。让我们从全局执行上下文中查找，并没有找到标记为`counter`的变量。JavaScript将会将其计算为`counter = undefined + 1`，声明了一个新的标记为`counter`的局部变量，并将数字`1`分配给了它，因为`undefined`将会转换成数字`0`。
13. 第五行，我们将变量`counter`的内容返回，或者说返回数字`1`。将局部执行上下文销毁，伴随着变量`counter`。
14. 返回到第十行，这个函数的返回值（`1`）将分配给变量`c1`。
15. 第十一行，重复第10~11步，`c2`也被分配了数字`1`。
16. 第十二行，重复第10~11步，`c3`也被分配了数字`1`。
17. 第十三行，我们将变量`c1`，`c2`和`c3`的内容输出。

亲自尝试一下，看看会发生什么。你将会注意到程序并没有输出`1`，`1`和`1`，正如你通过我之前的解释所期望的那样。代替输出的是`1`，`2`和`3`，怎么会这样？

不知何故，这个`increment`函数记住了变量`counter`的值，它的工作原理怎样的？

`counter`是在全局上下文中吗？尝试`console.log(counter)`，会得到一个`undefined`，所以并不是这样的。

也许，当你调用`increment`时，不知何故它会返回到它被创建时的函数（`createCounter`）？怎么会这样呢？变量`increment`包含函数定义，而不是它来自何处，所以并不是这样。

所以这应该是另一种机制，**闭包**。我们终于找到了它，丢失的那一块碎片。

下面是它的工作原理。每当你声明一个函数时，并且将它分配给一个变量，用来存储函数定义，以及闭包。闭包包含在函数创建时所在作用域中的所有变量。它类似于“背包”。函数定义附带一个小的“背包”。它在包中存储了函数定义创建时所在作用域中的所有变量。

所以我们之前的解释是错误的。让我们再试一次，但这一次是正确的。

```javascript
1: function createCounter() {
 2:   let counter = 0
 3:   const myFunction = function() {
 4:     counter = counter + 1
 5:     return counter
 6:   }
 7:   return myFunction
 8: }
 9: const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log('example increment', c1, c2, c3)
```

1. 第一到八行，我们在全局上下文中创建了一个新的变量`createCounter`并且分配给它一个函数定义。和之前一样。
2. 第九行，我们在全局上下文中创建了一个名为`counter`的变量。和之前一样。
3. 还是在第九行，我们需要调用名为`createCounter`的函数并将返回值分配给变量`increment`。和之前一样。
4. 第一到八行，调用函数。创建一个新的局部执行上下文。和之前一样。
5. 第二行，在局部执行上下文中声明一个名为`counter`的变量，并将数字`0`分配给`counter`。和之前一样。
6. 第三到六行，声明一个名为`myFunction`的变量。这个变量声明在局部执行上下文中。这个变量的内容是另一个函数定义。如第四和第五行所定义的。现在我们创建一个*闭包*并且将其作为函数定义的一部分。闭包包含当前作用域内所有的变量，在这个例子中，闭包包含的变量就是`counter`（值为`0`）。
7. 第七行，将变量`myFunction`的内容作为返回值。局部执行上下文被删除，`myFunction`和`counter`不再存在。控制器返回到当前调用的上下文。所以我们将函数定义和它的闭包一同返回，“背包”里包含它创建时所在作用域内的所有变量。
8. 第九行，在调用上下文中，实际就是全局执行上下文。将`createCounter`的返回值分配给变量`increment`。变量`increment`现在包含一个函数定义（以及闭包）。函数定义是通过变量`createCounter`返回的。现在它不再被标记为`myFunction`，但是它是相同的函数定义。在全局上下文中，它被标记为`increment`。
9. 第十行，声明一个新的变量（`c1`）。
10. 第十行（再次），查找变量`increment`，发现它是一个函数，调用它。它包含从前面返回的函数定义，如第四到第五行所定义的。（它还有一个带变量的“背包”）
11. 创建一个新的执行上下文。没有参数。开始执行这个函数。
12. 第四行，`counter = counter + 1`。我们需要查找变量`counter`，在我们查找局部或者全局执行上下文之前，让我们看看我们的“背包”，我们来检查闭包。瞧，闭包包含一个名为`counter`的变量，其值为`0`。在第四行的表达式之后，其值设置为了`1`。并且将它再次存放到“背包”中。现在闭包包含一个值为`1`的变量`counter`。
13. 第五行，我们将变量`counter`的内容返回，或者说是数字`1`。我们销毁局部执行上下文。
14. 返回到第十行。返回值`1`被分配给了变量`c1`。
15. 第十一行，我们重复步骤10-14，这一次，当我们查看我们的闭包时，我们发现变量`counter`的值为`1`。它是程序在第十二步或者第四行中设置的。它的值被递增并在`increment`函数的闭包中存储为`2`。并且`c2`被分配了`2`。
16. 第十二行，我们重复步骤10-14，`c3`被分配了`3`。
17. 第十三行，我们将变量`c1`，`c2`和`c3`的内容输出。

所以现在我们理解了这是如何工作的。要记住的关键是当函数被声明时，它包含一个函数定义和一个闭包。**闭包是函数创建时所在作用域内所有变量的集合。**

你也许会问，是不是所有的函数都有闭包，甚至是在全局作用域内创建的函数？答案是肯定的，在全局作用域创建的函数也有闭包。但是由于这些函数是在全局作用域内创建的，他们可以访问全局作用域内所有的变量，此时闭包的概念并不真正相关。

当一个函数返回函数时，闭包的概念就变得更相关了。返回的函数可以访问不在全局作用域存在的变量，但是它们仅存在于其闭包内。

#### 不是那么简单的闭包

有时闭包出现在你甚至没注意到它的时候。您可能已经看到了我们称之为部分应用程序的示例。就像下面的代码一样。

```javascript
let c = 4
const addX = x => n => n + x
const addThree = addX(3)
let d = addThree(c)
console.log('example partial application', d)
```

如果箭头函数超出了你的理解，下面是等价的。

```javascript
let c = 4
function addX(x) {
  return function(n) {
     return n + x
  }
}
const addThree = addX(3)
let d = addThree(c)
console.log('example partial application', d)
```

我们声明了一个通用的接受一个参数（`x`）并返回另一个函数定义的加法函数`addX`。

返回的函数也接受一个参数并将其与变量`x`相加。

变量`x`是闭包的一部分。当变量`addThree`在全局上下文中声明时，它被分配了一个函数定义以及一个闭包。闭包包含变量`x`。

所以现在变量`addThree`被调用执行，它接受它闭包中的变量`x`和作为参数传递的变量`n`，并且返回和。

在这个例子中，控制台打印输出数字`7`。

#### 结论

我通过**背包类比**来永远记住闭包的。当一个函数创建、传递或从另一个函数返回时，它随身携带着一个“背包”，并且在背包内有函数创建时所在作用域内所有的变量。

> 如果你喜欢阅读本文，请不要忘记掌声。*👏*
>
> 谢谢你。

