### [译]我从未理解过的JavaScript闭包

> [i-never-understood-javascript-closures](https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8)

​        正如标题所述，JavaScript闭包对我来说一直是一个迷，我看了许多文章，在我工作中我也使用过闭包，有时候我甚至使用了闭包而没意识到我正在使用闭包。

​        最近我去参加一个演讲，有人用一种让我感兴趣的方式来解释它。我也准备在这篇文章中通过这种方式来解释闭包。让我向[CodeSmith](https://www.codesmith.io/)的优秀成员以及他们的*JavaScript The Hard Parts*系列表示敬意。

#### 在我们开始之前

在理解闭包之前我们需要理解一些重要的概念，其中之一就是**执行上下文**。这篇文章[What is the Execution Context & Stack in JavaScript?](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/#first-article)对执行上下文有一个很好的说明，引用这篇文章的内容：

>代码在JavaScript中执行时，执行它的环境是非常重要的，并被评估为以下几项之一：
>
>**全局代码** —— 第一次执行代码时的默认环境
>
>**函数代码** —— 每当执行流程进入到函数体时
>
>(...)
>
>(…)，让我们把`执行上下文`视为正在评估当前代码的环境/作用域

就是说，当我们启动程序时，我们从全局执行上下文开始。一些变量在全局执行上下文中声明。我们将这些变量称为全局变量。当程序调用函数时，会发生什么？几个步骤：

1. JavaScript创建一个新的执行上下文，一个局部执行上下文
2. 这个局部执行上下文将有一组自己的变量，这些变量将是局部执行上下文的本地变量
3. 这个新的执行上下文将会抛出到**执行堆栈**中。将执行堆栈视为一种机制，可以跟踪程序执行的位置。

函数什么时候结束？当它碰到一个`return`语句或者是碰到一个结束括号`}`。当函数结束时，会执行以下步骤：

1. 局部执行上下文从执行堆栈中弹出
2. 函数将返回值发送给调用上下文。调用上下文就是调用这个函数的执行上下文，它可能时全局上下文或者是另一个局部执行上下文。它取决于调用执行上下文处理这个返回值所处的位置。这个返回值可以是一个对象、一个数组、一个函数、一个布尔值，甚至是任何东西。如果这个函数没有`return`语句，将会返回`undefined`。
3. 这个局部执行上下文将会被销毁，这很重要。销毁，所有在局部执行上下文中声明的变量将会被擦除。它们将不在存在。这也是为什么它们被称为局部变量的原因。

#### 一个非常基本的例子

在我们学习闭包之前，让我们来看看下面这段代码。这似乎非常简单，阅读这篇文章的任何人都可能知道它如何执行的。

```javascript
1: let a = 3
2: function addTwo(x) {
3:   let ret = x + 2
4:   return ret
5: }
6: let b = addTwo(a)
7: console.log(b)
```

为了理解JavaScript引擎真正的工作原理，让我们详细分析一下。

1. 在第一行在全局上下文中声明了一个变量`a`，并将数字`3`分配给了它。

2. 接下来它变得棘手了。第二行到第五行是真的在一起的。这里发生了什么？我们在全局上下文中声明了一个变量`addTwo`。我们分配给它什么呢？一个函数定义。两个括号`{}`之间的任何内容都分配给变量`addTwo`。该函数内的代码并未被获取，未被执行，只是存入到一个变量中供我们将来使用。

3. 现在让我们看看第六行，它看起来很简单，但这里需要解开很多细节。首先我们在全局上下文中声明了一个变量，并将其标记为`b`，声明变量后，它的值为`undefined`。

4. 接下来，还是在第六行，我们看见了一个赋值操作符，我们准备为变量`b`分配一个新的值，接下来我们看到一个被调用的函数，当你看到一个变量后面跟着圆括号`(...)`，那就是一个函数被调用的信号。快进，每个函数都会返回一些东西（也许是一个值，一个对象或者`undefined`）。无论这个函数返回什么都会分配给变量`b`。

5. 但是首先我们需要调用标记为`addTwo`的函数。JavaScript会在全局上下文的内存中查找一个叫做`addTwo`的变量。噢，它找到了一个，它是定义在步骤二（或者说第二到五行）。并且看到变量`addTwo`包含一个函数定义。请注意，变量`a`是作为一个参数传递给函数。JavaScript在全局上下文的内存中查找一个叫`a`的变量，找到它了，发现它的值是`3`并且将数字`3`作为一个参数传递给函数。准备执行该函数。

6. 现在这个执行上下文将会被切换。一个新的局部执行上下文将会被创建，让我们将它命名为`addTwo的执行上下文`。这个执行上下文将会被推送到调用堆栈中，我们在局部上下文中做的第一件事是什么呢？

7. 你可能会想说：“在局部上下文中声明一个新的变量`ret`。这并不是答案。正确的答案是，我们首先需要查看函数的参数，在局部上下文中声明一个新的变量`x`。并且在之前我们将值`3`作为参数传递过来了，将数字`3`分配给变量`x`。

8. 下一步是：在局部上下文中声明一个新的变量`ret`。它的值将会被设置为`undefined`（就像步骤三一样）

9. 还是在第三行，一个加法需要被执行，首先我们需要变量`x`的值，JavaScript将会查找一个叫做`x`的变量。它首先会在局部上下文中查找这个变量，它找到了一个，这个值是`3`。第二个操作数是数字`2`。这个加法的结果（`5`）将会被分配给变量`ret`。

10. 第四行，我们将变量`ret`的内容返回。在局部上下文中再次查找，`ret`的值为`5`。这个函数返回数字`5`，函数结束。

11. 第四到第五行。函数结束。这个局部执行上下文将会被销毁，变量`ret`和`x`将会被擦除。它们将不在存在。这个上下文将会从执行堆栈中压出，并且将返回值返回给调用上下文。在当前情况下，调用上下文就是全局上下文，因为函数`addTwo`是在全局上下文中被调用的。

12. 现在我们来看看我们在第四步中停下来的地方。这个返回值（`数字5`）将会分配给变量`b`。我们仍然在小程序的第六行。

13. 我不再细讲了，但是在第七行，这个变量`b`的内容将会在控制台打印出来。在我们的例子中就是数字`5`。

对于一个非常简单的程序来说，这是一个非常冗长的解释。我们甚至还没涉及到闭包。我保证会到达那里，但是我们还得再绕一两次。

#### 词法作用域

我们需要了解词法作用域的某些方面。看一下下面的例子。

```javascript
1: let val1 = 2
2: function multiplyThis(n) {
3:   let ret = n * val1
4:   return ret
5: }
6: let multiplied = multiplyThis(6)
7: console.log('example of scope:', multiplied)
```

这里的想法是，我们在全局上下文中有一些变量，在局部上下文中也有一些变量。JavaScript的一个复杂之处在于它如何查找这些变量。如果它在局部上下文中未找到该变量，它将会去调用上下文中查找，如果在它的调用上下文中还是未找到该变量。反复地，直到它在全局上下文中查找该变量（如果它没有找到该变量，该变量的值就是`undefined`）。按照上面的例子，它将会证明这个说法。如果你知道作用域的工作原理，你可以跳过这节内容。

1. 在全局上下文中声明一个变量`val1`并且将数字`2`分配给它。
2. 第二到五行，声明一个新的变量`multiplyThis`并且给它分配一个函数定义。
3. 第六行在全局上下文中声明一个新的变量`mutiplied`。
4. 在全局上下文的内存中取出变量`multiplyThis`的值并将其作为函数执行。将数字`6`作为参数传递给它。
5. 一个新的函数调用 = 一个新的执行上下文。创建一个新的局部上下文。
6. 